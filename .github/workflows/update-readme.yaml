# .github/workflows/update-readme.yml
name: Update README with Table of Contents

on:
  push:
    branches: [ main, master ]
    paths:
      - '*/README.md'
      - '**/*.ps1'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch: # Manueller Trigger

permissions:
  contents: write  # Berechtigung zum Schreiben von Inhalten
  pull-requests: write  # Berechtigung für Pull Requests

jobs:
  update-readme:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'

    - name: Generate README Content
      run: |
        cat > generate_readme.py << 'EOF'
        import os
        import re
        from datetime import datetime

        def count_ps1_files(directory):
            """Zählt PowerShell-Dateien in einem Verzeichnis"""
            count = 0
            if os.path.exists(directory):
                for file in os.listdir(directory):
                    if file.endswith('.ps1'):
                        count += 1
            return count

        def extract_description_from_readme(readme_path):
            """Extrahiert die erste Beschreibung aus einer README"""
            if not os.path.exists(readme_path):
                return "Keine Beschreibung verfügbar"
            
            try:
                with open(readme_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # Suche nach der ersten Beschreibung nach dem Titel
                lines = content.split('\n')
                for i, line in enumerate(lines):
                    if line.strip() and not line.startswith('#') and not line.startswith('>'): 
                        if len(line.strip()) > 20:  # Mindestlänge für Beschreibung
                            return line.strip()
                
                return "PowerShell-Tools für Systemverwaltung"
            except:
                return "Keine Beschreibung verfügbar"

        def get_category_description(category_name):
            """Erstellt eine Beschreibung basierend auf dem Kategorienamen"""
            descriptions = {
                'GPO': 'Group Policy Object Tools',
                'HYPER-V': 'Hyper-V Management Tools',
                'WSUS': 'Windows Update Services Tools',
                'WDS': 'Windows Deployment Services Tools',
                'SYS': 'System Administration Tools'
            }
            return descriptions.get(category_name, f'{category_name} Tools')

        def generate_directory_structure(categories):
            """Generiert die Verzeichnisstruktur basierend auf gefundenen Kategorien"""
            structure_lines = ["DSE"]
            
            for i, category in enumerate(categories):
                category_name = category['name']
                description = get_category_description(category_name)
                
                # Verwende verschiedene Tree-Zeichen
                if i == len(categories) - 1:
                    prefix = "└── "
                else:
                    prefix = "├── "
                
                structure_lines.append(f"{prefix}{category_name}{'':20} ")
            
            return structure_lines

        # Repository-Struktur scannen
        categories = []
        base_dirs = [d for d in os.listdir('.') if os.path.isdir(d) and not d.startswith('.') and d not in ['node_modules']]
        
        for directory in sorted(base_dirs):
            readme_path = os.path.join(directory, 'README.md')
            script_count = count_ps1_files(directory)
            
            if script_count > 0 or os.path.exists(readme_path):
                description = extract_description_from_readme(readme_path)
                categories.append({
                    'name': directory,
                    'description': description,
                    'script_count': script_count,
                    'has_readme': os.path.exists(readme_path)
                })

        # README-Inhalt generieren
        total_scripts = sum(cat['script_count'] for cat in categories)
        update_time = datetime.now().strftime('%d.%m.%Y')
        update_timestamp = datetime.now().strftime('%d.%m.%Y um %H:%M:%S')
        
        readme_lines = [
            "Eine umfassende Sammlung von PowerShell-Tools für die effiziente Verwaltung von Windows-Domänenumgebungen und Enterprise-Systemen.",
            "",
            f"> **Letztes Update:** {update_time}",
            f"> **Gesamtanzahl Scripts:** {total_scripts}",
            f"> **Kategorien:** {len(categories)}",
            "",
            "## Inhaltsverzeichnis",
            "",
            "| Kategorie | Scripts | Dokumentation |",
            "|-----------|---------|---------------|"
        ]

        for category in categories:
            readme_link = f"[README]({category['name']}/README.md)" if category['has_readme'] else "Keine"
            readme_lines.append(f"| **[{category['name']}]({category['name']}/)** | {category['script_count']} | {readme_link} |")

        for category in categories:
            readme_lines.append(f"### {category['name']}")
            if category['has_readme']:
                readme_lines.append(f"**[Zur vollständigen Dokumentation]({category['name']}/README.md)**")
                readme_lines.append("")
            readme_lines.append(f"{category['description']}")
            readme_lines.append("")
            readme_lines.append(f"- **Anzahl Scripts:** {category['script_count']}")
            
            # Liste der Scripts hinzufügen
            script_files = []
            if os.path.exists(category['name']):
                for file in sorted(os.listdir(category['name'])):
                    if file.endswith('.ps1'):
                        script_files.append(file)
            
            if script_files:
                readme_lines.append("- **Verfügbare Scripts:**")
                for script in script_files:
                    readme_lines.append(f"  - `{script}`")
            
            readme_lines.append("")

        # Dynamische Repository-Struktur generieren
        structure_lines = generate_directory_structure(categories)
        
        readme_lines.extend([
            "## Entwicklung & Beitrag",
            "",
            "### Repository-Struktur",
            "```"
        ])
        
        readme_lines.extend(structure_lines)
        
        readme_lines.extend([
            "```",
            f"> Automatisch generiert am {update_timestamp} UTC"
        ])

        # README-Datei schreiben
        with open('README.md', 'w', encoding='utf-8') as f:
            f.write('\n'.join(readme_lines))

        print("README.md wurde erfolgreich generiert!")
        print(f"Gefundene Kategorien: {len(categories)}")
        print(f"Gesamtanzahl Scripts: {total_scripts}")
        for cat in categories:
            print(f"  - {cat['name']}: {cat['script_count']} Scripts")
        EOF
        
        python generate_readme.py

    - name: Auto-commit README changes
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: 'Auto-update README.md mit aktuellem Inhaltsverzeichnis'
        file_pattern: 'README.md'
        commit_user_name: 'github-actions[bot]'
        commit_user_email: '41898282+github-actions[bot]@users.noreply.github.com'
        commit_author: 'github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>'
        skip_dirty_check: false
        skip_fetch: false
        skip_checkout: false